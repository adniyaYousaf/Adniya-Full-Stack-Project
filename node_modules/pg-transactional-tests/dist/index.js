"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollbackTransaction = exports.startTransaction = exports.unpatchPgForTransactions = exports.patchPgForTransactions = void 0;
const pg_1 = require("pg");
let transactionId = 0;
let client;
let connectPromise;
let prependStartTransaction = false;
const { connect, query } = pg_1.Client.prototype;
const { connect: poolConnect, query: poolQuery } = pg_1.Pool.prototype;
const patchPgForTransactions = () => {
    pg_1.Client.prototype.connect = function (callback) {
        return __awaiter(this, void 0, void 0, function* () {
            // @types/pg says there is no second parameter, but actually pg itself relies on it
            const cb = callback;
            if (!client)
                client = this;
            if (connectPromise) {
                yield connectPromise;
                cb === null || cb === void 0 ? void 0 : cb(undefined, client);
                return;
            }
            connectPromise = new Promise((resolve, reject) => {
                connect.call(client, (err) => {
                    if (err) {
                        cb === null || cb === void 0 ? void 0 : cb(err);
                        reject(err);
                    }
                    else {
                        cb === null || cb === void 0 ? void 0 : cb(undefined, client);
                        resolve();
                    }
                });
            });
            return connectPromise;
        });
    };
    pg_1.Pool.prototype.connect = function (cb) {
        this.options.max = 1;
        if (cb) {
            // @ts-expect-error whatever
            poolConnect.call(this, cb);
            return undefined;
        }
        else {
            return poolConnect.call(this);
        }
    };
    pg_1.Client.prototype.query = function (inputArg, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            let input = inputArg;
            const sql = (typeof input === 'string' ? input : input.text)
                .trim()
                .toUpperCase();
            // Don't wrap in transactions for selects as they won't mutate
            if (!sql.startsWith('SELECT')) {
                let replacingSql;
                if (prependStartTransaction) {
                    prependStartTransaction = false;
                    yield this.query('BEGIN');
                }
                if (sql.startsWith('START TRANSACTION') || sql.startsWith('BEGIN')) {
                    if (transactionId > 0) {
                        replacingSql = `SAVEPOINT "${transactionId++}"`;
                    }
                    else {
                        transactionId = 1;
                    }
                }
                else {
                    const isCommit = sql.startsWith('COMMIT');
                    const isRollback = !isCommit && sql.startsWith('ROLLBACK');
                    if (isCommit || isRollback) {
                        if (transactionId === 0) {
                            throw new Error(`Trying to ${isCommit ? 'COMMIT' : 'ROLLBACK'} outside of transaction`);
                        }
                        if (transactionId > 1) {
                            const savePoint = --transactionId;
                            replacingSql = `${isCommit ? 'RELEASE' : 'ROLLBACK TO'} SAVEPOINT "${savePoint}"`;
                        }
                        else {
                            transactionId = 0;
                        }
                    }
                }
                if (replacingSql) {
                    if (typeof input === 'string') {
                        input = replacingSql;
                    }
                    else {
                        input.text = replacingSql;
                    }
                }
            }
            yield pg_1.Client.prototype.connect.call(this);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return query.call(client, input, ...args);
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    pg_1.Pool.prototype.query = function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.connect();
            try {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return client.query(...args);
            }
            finally {
                client.release();
            }
        });
    };
};
exports.patchPgForTransactions = patchPgForTransactions;
const unpatchPgForTransactions = () => {
    transactionId = 0;
    client = undefined;
    connectPromise = undefined;
    pg_1.Client.prototype.connect = connect;
    pg_1.Client.prototype.query = query;
    pg_1.Pool.prototype.connect = poolConnect;
    pg_1.Pool.prototype.query = poolQuery;
};
exports.unpatchPgForTransactions = unpatchPgForTransactions;
const startTransaction = () => __awaiter(void 0, void 0, void 0, function* () {
    prependStartTransaction = true;
});
exports.startTransaction = startTransaction;
const rollbackTransaction = () => __awaiter(void 0, void 0, void 0, function* () {
    if (transactionId > 0) {
        yield (client === null || client === void 0 ? void 0 : client.query('ROLLBACK'));
    }
});
exports.rollbackTransaction = rollbackTransaction;
